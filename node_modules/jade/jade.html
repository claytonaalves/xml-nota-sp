<h1>Jade</h1>

<p>The jade template engine for node.js</p>

<h2>Synopsis</h2>

<pre><code>jade [-h|--help] [-v|--version] [-o|--obj STR]
     [-O|--out DIR] [-p|--path PATH] [-P|--pretty]
     [-c|--client] [-D|--no-debug]
</code></pre>

<h2>Examples</h2>

<p>translate jade the templates dir</p>

<pre><code>$ jade templates
</code></pre>

<p>create {foo,bar}.html</p>

<pre><code>$ jade {foo,bar}.jade
</code></pre>

<p>jade over stdio</p>

<pre><code>$ jade &lt; my.jade &gt; my.html
</code></pre>

<p>jade over s</p>

<pre><code>$ echo "h1 Jade!" | jade
</code></pre>

<p>foo, bar dirs rendering to /tmp</p>

<pre><code>$ jade foo bar --out /tmp
</code></pre>

<p>compile client-side templates without debugging
  instrumentation, making the output javascript
  very light-weight. This requires runtime.js
  in your projects.</p>

<pre><code> $ jade --client --no-debug &lt; my.jade
</code></pre>

<h2>Tags</h2>

<p>Tags are simply nested via whitespace, closing
  tags defined for you. These indents are called "blocks".</p>

<pre><code>ul
  li
    a Foo
  li
    a Bar
</code></pre>

<p>You may have several tags in one "block":</p>

<pre><code>ul
  li
    a Foo
    a Bar
    a Baz
</code></pre>

<h2>Self-closing Tags</h2>

<p>Some tags are flagged as self-closing by default, such
  as <code>meta</code>, <code>link</code>, and so on. To explicitly self-close
  a tag simply append the <code>/</code> character:</p>

<pre><code> foo/
 foo(bar='baz')/
</code></pre>

<p>Would yield:</p>

<pre><code> &lt;foo/&gt;
 &lt;foo bar="baz"/&gt;
</code></pre>

<h2>Attributes</h2>

<p>Tag attributes look similar to HTML, however
  the values are regular JavaScript, here are
  some examples:</p>

<pre><code>a(href='google.com') Google
a(class='button', href='google.com') Google
</code></pre>

<p>As mentioned the attribute values are just JavaScript,
  this means ternary operations and other JavaScript expressions
  work just fine:</p>

<pre><code>body(class=user.authenticated ? 'authenticated' : 'anonymous')
a(href=user.website || 'http://google.com')
</code></pre>

<p>Multiple lines work too:</p>

<pre><code>input(type='checkbox',
  name='agreement',
  checked)
</code></pre>

<p>Multiple lines without the comma work fine:</p>

<pre><code>input(type='checkbox'
  name='agreement'
  checked)
</code></pre>

<p>Funky whitespace? fine:</p>

<pre><code>input(
  type='checkbox'
  name='agreement'
  checked)
</code></pre>

<h2>Boolean attributes</h2>

<p>Boolean attributes are mirrored by Jade, and accept
  bools, aka <em>true</em> or <em>false</em>. When no value is specified
  <em>true</em> is assumed. For example:</p>

<pre><code>input(type="checkbox", checked)
// =&gt; "&lt;input type="checkbox" checked="checked" /&gt;"
</code></pre>

<p>For example if the checkbox was for an agreement, perhaps <code>user.agreed</code>
  was <em>true</em> the following would also output 'checked="checked"':</p>

<pre><code> input(type="checkbox", checked=user.agreed)
</code></pre>

<h2>Class attributes</h2>

<p>The <em>class</em> attribute accepts an array of classes,
  this can be handy when generated from a javascript
  function etc:</p>

<pre><code>classes = ['foo', 'bar', 'baz']
a(class=classes)
// =&gt; "&lt;a class="foo bar baz"&gt;&lt;/a&gt;"
</code></pre>

<h2>Class literal</h2>

<p>Classes may be defined using a ".CLASSNAME" syntax:</p>

<pre><code> .button
 // =&gt; "&lt;div class="button"&gt;&lt;/div&gt;"
</code></pre>

<p>Or chained:</p>

<pre><code> .large.button
 // =&gt; "&lt;div class="large button"&gt;&lt;/div&gt;"
</code></pre>

<p>The previous defaulted to divs, however you
  may also specify the tag type:</p>

<pre><code>  h1.title My Title
  // =&gt; "&lt;h1 class="title"&gt;My Title&lt;/h1&gt;"
</code></pre>

<h2>Id literal</h2>

<p>Much like the class literal there's an id literal:</p>

<pre><code>#user-1
// =&gt; "&lt;div id="user-1"&gt;&lt;/div&gt;"
</code></pre>

<p>Again we may specify the tag as well:</p>

<pre><code>ul#menu
  li: a(href='/home') Home
  li: a(href='/store') Store
  li: a(href='/contact') Contact
</code></pre>

<p>Finally all of these may be used in any combination,
  the following are all valid tags:</p>

<pre><code>a.button#contact(style: 'color: red') Contact
a.button(style: 'color: red')#contact Contact
a(style: 'color: red').button#contact Contact
</code></pre>

<h2>Block expansion</h2>

<p>Jade supports the concept of "block expansion", in which
  using a trailing ":" after a tag will inject a block:</p>

<pre><code>ul
  li: a Foo
  li: a Bar
  li: a Baz
</code></pre>

<h2>Text</h2>

<p>Arbitrary text may follow tags:</p>

<pre><code> p Welcome to my site
</code></pre>

<p>yields:</p>

<pre><code> &lt;p&gt;Welcome to my site&lt;/p&gt;
</code></pre>

<h2>Pipe text</h2>

<p>Another form of text is "pipe" text. Pipes act
  as the text margin for large bodies of text.</p>

<pre><code>p
  | This is a large
  | body of text for
  | this tag.
  | 
  | Nothing too
  | exciting.
</code></pre>

<p>yields:</p>

<pre><code>&lt;p&gt;This is a large
body of text for
this tag.

Nothing too
exciting.
&lt;/p&gt;
</code></pre>

<p>Using pipes we can also specify regular Jade tags
  within the text:</p>

<pre><code>p
  | Click to visit
  a(href='http://google.com') Google
  | if you want.
</code></pre>

<h2>Text only tags</h2>

<p>As an alternative to pipe text you may add
  a trailing "." to indicate that the block
  contains nothing but plain-text, no tags:</p>

<pre><code>p.
  This is a large
  body of text for
  this tag.

  Nothing too
  exciting.
</code></pre>

<p>Some tags are text-only by default, for example
  <em>script</em>, <em>textarea</em>, and <em>style</em> tags do not
  contain nested HTML so Jade implies the trailing ".":</p>

<pre><code>script
  if (foo) {
    bar();
  }

style
  body {
    padding: 50px;
    font: 14px Helvetica;
  }
</code></pre>

<h2>Template script tags</h2>

<p>Sometimes it's useful to define HTML in script
  tags using Jade, typically for client-side templates.</p>

<p>To do this simply give the <em>script</em> tag an arbitrary
  <em>type</em> attribute such as <em>text/x-template</em>:</p>

<pre><code>script(type='text/template')
  h1 Look!
  p Jade still works in here!
</code></pre>

<h2>Interpolation</h2>

<p>Both plain-text and piped-text support interpolation,
  which comes in two forms, escapes and non-escaped. The
  following will output the <em>user.name</em> in the paragraph
  but HTML within it will be escaped to prevent XSS attacks:</p>

<pre><code>p Welcome #{user.name}
</code></pre>

<p>The following syntax is identical however it will <em>not</em> escape
  HTML, and should only be used with strings that you trust:</p>

<pre><code>p Welcome !{user.name}
</code></pre>

<h2>Inline HTML</h2>

<p>Sometimes constructing small inline snippets of HTML
  in Jade can be annoying, luckily we can add plain
  HTML as well:</p>

<pre><code>p Welcome &lt;em&gt;#{user.name}&lt;/em&gt;
</code></pre>

<h2>Code</h2>

<p>To buffer output with Jade simply use <em>=</em> at the beginning
  of a line or after a tag. This method escapes any HTML
  present in the string.</p>

<pre><code>p= user.description
</code></pre>

<p>To buffer output unescaped use the <em>!=</em> variant, but again
  be careful of XSS.</p>

<pre><code>p!= user.description
</code></pre>

<p>The final way to mess with JavaScript code in Jade is the unbuffered
  <em>-</em>, which can be used for conditionals, defining variables etc:</p>

<pre><code>- var user = { description: 'foo bar baz' }
#user
  - if (user.description) {
    h2 Description
    p.description= user.description
  - }
</code></pre>

<p>When compiled blocks are wrapped in anonymous functions, so the
   following is also valid, without braces:</p>

<pre><code> - var user = { description: 'foo bar baz' }
 #user
   - if (user.description)
     h2 Description
     p.description= user.description
</code></pre>

<p>If you really want you could even use <code>.forEach()</code> and others:</p>

<pre><code>- users.forEach(function(user){
  .user
    h2= user.name
    p User #{user.name} is #{user.age} years old
- })
</code></pre>

<p>Taking this further Jade provides some syntax for conditionals,
   iteration, switch statements etc. Let's look at those next!</p>

<h2>Assignment</h2>

<p>Jade's first-class assignment is simple, simply use the <em>=</em>
  operator and Jade will <em>var</em> it for you. The following are equivalent:</p>

<pre><code>- var user = { name: 'tobi' }
user = { name: 'tobi' }
</code></pre>

<h2>Conditionals</h2>

<p>Jade's first-class conditional syntax allows for optional
  parenthesis, and you may now omit the leading <em>-</em> otherwise
  it's identical, still just regular javascript:</p>

<pre><code>user = { description: 'foo bar baz' }
#user
  if user.description
    h2 Description
    p.description= user.description
</code></pre>

<p>Jade provides the negated version, <em>unless</em> as well, the following
  are equivalent:</p>

<pre><code>- if (!(user.isAnonymous))
  p You're logged in as #{user.name}

unless user.isAnonymous
  p You're logged in as #{user.name}
</code></pre>

<h2>Iteration</h2>

<p>JavaScript's <em>for</em> loops don't look very declarative, so Jade
  also provides its own <em>for</em> loop construct, aliased as <em>each</em>:</p>

<pre><code>for user in users
  .user
    h2= user.name
    p user #{user.name} is #{user.age} year old
</code></pre>

<p>As mentioned <em>each</em> is identical:</p>

<pre><code> each user in users
   .user
     h2= user.name
</code></pre>

<p>If necessary the index is available as well:</p>

<pre><code>  for user, i in users
    .user(class='user-#{i}')
      h2= user.name
</code></pre>

<p>Remember, it's just JavaScript:</p>

<pre><code>  ul#letters
    for letter in ['a', 'b', 'c']
      li= letter
</code></pre>

<h2>Mixins</h2>

<p>Mixins provide a way to define jade "functions" which "mix in"
  their contents when called. This is useful for abstracting
  out large fragments of Jade.</p>

<p>The simplest possible mixin which accepts no arguments might
  look like this:</p>

<pre><code>  mixin hello
    p Hello
</code></pre>

<p>You use a mixin by placing <code>+</code> before the name:</p>

<pre><code>  +hello
</code></pre>

<p>For something a little more dynamic, mixins can take
   arguments, the mixin itself is converted to a javascript
   function internally:</p>

<pre><code>   mixin hello(user)
     p Hello #{user}

   +hello('Tobi')
</code></pre>

<p>Yields:</p>

<pre><code>   &lt;p&gt;Hello Tobi&lt;/p&gt;
</code></pre>

<p>Mixins may optionally take blocks, when a block is passed
  its contents becomes the implicit <code>block</code> argument. For
  example here is a mixin passed a block, and also invoked
  without passing a block:</p>

<pre><code>  mixin article(title)
    .article
      .article-wrapper
        h1= title
        if block
          block
        else
          p No content provided

  +article('Hello world')

  +article('Hello world')
    p This is my
    p Amazing article
</code></pre>

<p>yields:</p>

<pre><code>   &lt;div class="article"&gt;
     &lt;div class="article-wrapper"&gt;
       &lt;h1&gt;Hello world&lt;/h1&gt;
       &lt;p&gt;No content provided&lt;/p&gt;
     &lt;/div&gt;
   &lt;/div&gt;

   &lt;div class="article"&gt;
     &lt;div class="article-wrapper"&gt;
       &lt;h1&gt;Hello world&lt;/h1&gt;
       &lt;p&gt;This is my&lt;/p&gt;
       &lt;p&gt;Amazing article&lt;/p&gt;
     &lt;/div&gt;
   &lt;/div&gt;
</code></pre>

<p>Mixins can even take attributes, just like a tag. When
  attributes are passed they become the implicit <code>attributes</code>
  argument. Individual attributes can be accessed just like
  normal object properties:</p>

<pre><code>  mixin centered
    .centered(class=attributes.class)
      block

  +centered.bold Hello world

  +centered.red
    p This is my
    p Amazing article
</code></pre>

<p>yields:</p>

<pre><code>   &lt;div class="centered bold"&gt;Hello world&lt;/div&gt;
   &lt;div class="centered red"&gt;
     &lt;p&gt;This is my&lt;/p&gt;
     &lt;p&gt;Amazing article&lt;/p&gt;
   &lt;/div&gt;
</code></pre>

<p>If you use <code>attributes</code> directly, <em>all</em> passed attributes
   get used:</p>

<pre><code>  mixin link
    a.menu(attributes)
      block

  +link.highlight(href='#top') Top
  +link#sec1.plain(href='#section1') Section 1
  +link#sec2.plain(href='#section2') Section 2
</code></pre>

<p>yields:</p>

<pre><code>   &lt;a href="#top" class="highlight menu"&gt;Top&lt;/a&gt;
   &lt;a id="sec1" href="#section1" class="plain menu"&gt;Section 1&lt;/a&gt;
   &lt;a id="sec2" href="#section2" class="plain menu"&gt;Section 2&lt;/a&gt;
</code></pre>

<p>If you pass arguments, they must directly follow the mixin:</p>

<pre><code>  mixin list(arr)
    if block
      .title
        block
    ul(attributes)
      each item in arr
        li= item

  +list(['foo', 'bar', 'baz'])(id='myList', class='bold')
</code></pre>

<p>yields:</p>

<pre><code>   &lt;ul id="myList" class="bold"&gt;
     &lt;li&gt;foo&lt;/li&gt;
     &lt;li&gt;bar&lt;/li&gt;
     &lt;li&gt;baz&lt;/li&gt;
   &lt;/ul&gt;
</code></pre>
